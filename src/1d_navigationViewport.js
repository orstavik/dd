/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@virtualstate/navigation@1.0.1-alpha.212/esnext/polyfill.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
let t; if ("undefined" != typeof window && window.navigation) { const e = window.navigation; !function (t) { if (!t) throw new Error("Expected Navigation") }(e), t = e } function e(t) { return function (t) { return !!t }(t) && ("string" == typeof t.type || "symbol" == typeof t.type) } class n extends Error { constructor(t) { super("AbortError" + (t ? `: ${t}` : "")), this.name = "AbortError" } } function i(t) { return t instanceof Error && "AbortError" === t.name } class r extends Error { constructor(t) { super("InvalidStateError" + (t ? `: ${t}` : "")), this.name = "InvalidStateError" } } function o(t) { return e(t) && function (t) { return t.hasOwnProperty("signal") }(t) && function (t) { return function (t) { return "object" == typeof t }(t) && "boolean" == typeof t.aborted && "function" == typeof t.addEventListener }(t.signal) } function s(t, e) { if (o(t) && t.signal.aborted && e instanceof Error && i(e)) return !0 } const a = Symbol.for("@opennetwork/environment/events/target/listeners"), c = Symbol.for("@opennetwork/environment/events/target/listeners/ignore"), u = Symbol.for("@opennetwork/environment/events/target/listeners/match"), h = Symbol.for("@opennetwork/environment/events/target/listeners/this"), l = Symbol.for("@opennetwork/environment/events/descriptor"); function d(t, e, n) { const i = function (t) { return function (t) { return !!t }(t) && !0 === t[l] }(n) ? n : void 0; return n => i ? i === n : (!e || e === n.callback) && t === n.type } function f(t) { return "function" == typeof t } const g = Symbol.for("@virtualstate/navigation/event-target/descriptors"); class v { [g] = [];[c] = new WeakSet; get [a]() { return [...this[g] ?? []] } [u](t) { const e = this[a], n = [...new Set([...e ?? [], ...this[g] ?? []])].filter((e => e.type === t || "*" === e.type)).filter((t => !this[c]?.has(t))), i = "string" == typeof t ? this[`on${t}`] : void 0; return "function" == typeof i && f(i) && n.push({ type: t, callback: i, [l]: !0 }), n } addEventListener(t, e, n) { const i = { ...n, isListening: () => !!this[g]?.find(d(t, e)), descriptor: { [l]: !0, ...n, type: t, callback: e }, timestamp: Date.now() }; i.isListening() || this[g]?.push(i.descriptor) } removeEventListener(t, e, n) { if (!f(e)) return; const i = this[a] ?? this[g] ?? [], r = i.findIndex(d(t, e, n)); if (-1 === r) return; const o = this[g]?.findIndex(d(t, e, n)) ?? -1; -1 !== o && this[g]?.splice(o, 1); const s = i[r]; s && this[c]?.add(s) } hasEventListener(t, e) { if (e && !f(e)) return !1; return (this[g]?.findIndex(d(t, e)) ?? -1) > -1 } } class p extends v { [h]; constructor(t = void 0) { super(), this[h] = t } async dispatchEvent(t) { const i = this[u]?.(t.type) ?? []; if (o(t) && t.signal.aborted) throw new n; const r = e(a = t) && !1 !== a.parallel; var a; const c = []; for (let e = 0; e < i.length; e += 1) { const n = i[e], a = (async () => { n.once && this.removeEventListener(n.type, n.callback, n), await n.callback.call(this[h] ?? this, t) })(); if (r) c.push(a); else { try { await a } catch (e) { s(t, e) || await Promise.reject(e) } if (o(t) && t.signal.aborted) return } } if (c.length) { const e = (await Promise.allSettled(c)).filter((t => "rejected" === t.status)); if (e.length) { let n = e; if (o(t) && t.signal.aborted && (n = n.filter((e => !s(t, e.reason)))), 1 === n.length) throw await Promise.reject(n[0].reason), n[0].reason; if (n.length > 1) throw new AggregateError(n.map((({ reason: t }) => t))) } } } } const y = { EventTarget: p, AsyncEventTarget: p, SyncEventTarget: p }; const m = y.EventTarget || y.SyncEventTarget || y.AsyncEventTarget; class w extends p { constructor(...t) { if (super(), m) { !function (t) { if ("function" != typeof t) throw new Error("Could not load EventTarget implementation") }(m); const { dispatchEvent: e } = new m(...t); this.dispatchEvent = e } } } class b extends w { addEventListener(t, e, n) { return function (t) { if ("function" != typeof t) throw new Error("Please us the function variant of event listener") }(e), super.addEventListener(t, e, "boolean" == typeof n ? { once: n } : n) } removeEventListener(t, e, n) { return function (t) { if ("function" != typeof t) throw new Error("Please us the function variant of event listener") }(e), super.removeEventListener(t, e) } } const E = "crypto" in globalThis && "function" == typeof globalThis.crypto.randomUUID ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : () => Array.from({ length: 5 }, (() => `${Math.random()}`.replace(/^0\./, ""))).join("-").replace(".", ""), S = Symbol.for("@virtualstate/navigation/getState"), k = Symbol.for("@virtualstate/navigation/entry/navigationType"), x = Symbol.for("@virtualstate/navigation/entry/knownAs"), T = Symbol.for("@virtualstate/navigation/entry/setState"); function L(t) { return "number" == typeof t || "boolean" == typeof t || "symbol" == typeof t || "bigint" == typeof t || "string" == typeof t } function P(t) { return !(!t && !L(t)) } class I extends b { #t; #e; get index() { return "number" == typeof this.#t ? this.#t : this.#t() } key; id; url; sameDocument; get [k]() { return this.#n.navigationType } get [x]() { const t = new Set(this.#n[x]); return t.add(this.id), t } #n; get [a]() { return [...super[a] ?? [], ...this.#n[a] ?? []] } constructor(t) { super(), this.#n = t, this.key = t.key || E(), this.id = E(), this.url = t.url ?? void 0, this.#t = t.index, this.sameDocument = t.sameDocument ?? !0, this.#e = t.state ?? void 0 } [S]() { return this.#n?.getState?.(this) } getState() { let t = this.#e; if (!P(t)) { const e = this[S](); P(e) && (t = this.#e = e) } return void 0 === t || L(t) ? t : ("function" == typeof t && (console.warn("State passed to Navigation.navigate was a function, this may be unintentional"), console.warn("Unless a state value is primitive, with a standard implementation of Navigation"), console.warn("your state value will be serialized and deserialized before this point, meaning"), console.warn("a function would not be usable.")), { ...t }) } [T](t) { this.#e = t } } function U(t) { let e, n; const i = new Promise(((t, i) => { e = t, n = i })); return R(e), R(n), { resolve: e, reject: n, promise: t ? i.catch(t) : i } } function R(t) { if (!t) throw new Error("Value not provided") } const C = "undefined" != typeof AbortController ? AbortController : void 0; if (!C) throw new Error("AbortController expected to be available or polyfilled"); const D = C; function j(t) { return A(t) && "function" == typeof t.then } function O(t, e = "Expected value") { if (!t) throw new Error(e) } function N(t) { return "rejected" === t.status } function A(t) { return !!t } const F = { EVENT_INTERCEPT_HANDLER: "You are using a non standard interface, please update your code to use event.intercept({ async handler() {} })\nThis will be removed when the first major release of @virtualstate/navigation is published" }; let q = !1, $ = !0; function H(t) { q = t } function V(t) { $ = t } function _(t, ...e) { if (!q) try { $ ? console.trace(F[t], ...e) : console.warn(F[t], ...e) } catch { } } const M = Symbol.for("@virtualstate/navigation/rollback"), W = Symbol.for("@virtualstate/navigation/unset"), K = Symbol.for("@virtualstate/navigation/transition/parentEventTarget"), z = Symbol.for("@virtualstate/navigation/transition/deferred/finished"), B = Symbol.for("@virtualstate/navigation/transition/deferred/committed"), G = Symbol.for("@virtualstate/navigation/transition/navigationType"), J = Symbol.for("@virtualstate/navigation/transition/entries/initial"), Y = Symbol.for("@virtualstate/navigation/transition/entries/finished"), Q = Symbol.for("@virtualstate/navigation/transition/index/initial"), X = Symbol.for("@virtualstate/navigation/transition/index/finished"), Z = Symbol.for("@virtualstate/navigation/transition/entry"), tt = Symbol.for("@virtualstate/navigation/transition/isCommitted"), et = Symbol.for("@virtualstate/navigation/transition/isFinished"), nt = Symbol.for("@virtualstate/navigation/transition/isRejected"), it = Symbol.for("@virtualstate/navigation/transition/known"), rt = Symbol.for("@virtualstate/navigation/transition/promises"), ot = Symbol.for("@virtualstate/navigation/intercept"), st = Symbol.for("@virtualstate/navigation/transition/isOngoing"), at = Symbol.for("@virtualstate/navigation/transition/isPending"), ct = Symbol.for("@virtualstate/navigation/transition/isAsync"), ut = Symbol.for("@virtualstate/navigation/transition/wait"), ht = Symbol.for("@virtualstate/navigation/transition/promise/resolved"), lt = Symbol.for("@virtualstate/navigation/transition/rejected"), dt = Symbol.for("@virtualstate/navigation/transition/beforeCommit"), ft = Symbol.for("@virtualstate/navigation/transition/commit"), gt = Symbol.for("@virtualstate/navigation/transition/finish"), vt = Symbol.for("@virtualstate/navigation/transition/start"), pt = Symbol.for("@virtualstate/navigation/transition/start/deadline"), yt = Symbol.for("@virtualstate/navigation/transition/error"), mt = Symbol.for("@virtualstate/navigation/transition/finally"), wt = Symbol.for("@virtualstate/navigation/transition/abort"), bt = Symbol.for("@virtualstate/navigation/transition/intercept/options/commit"), Et = Symbol.for("@virtualstate/navigation/transition/commit/isManual"); class St extends w { finished; committed; from; navigationType;[ct] = !1;[bt]; #n;[z] = U();[B] = U(); get [at]() { return !!this.#i.size } get [G]() { return this.#n[G] } get [J]() { return this.#n[J] } get [Q]() { return this.#n[Q] } get [Et]() { return !(!this[bt]?.includes("after-transition") && !this[bt]?.includes("manual")) } [Y];[X];[tt] = !1;[et] = !1;[nt] = !1;[st] = !1;[it] = new Set;[Z]; #i = new Set; #r = !1; #o = new D; get signal() { return this.#o.signal } get [rt]() { return this.#i } constructor(t) { super(), this[bt] = [], this[z] = t[z] ?? this[z], this[B] = t[B] ?? this[B], this.#n = t; const e = this.finished = this[z].promise, i = this.committed = this[B].promise; e.catch((t => t)), i.catch((t => t)), this.from = t.from, this.navigationType = t.navigationType, this[Y] = t[Y], this[X] = t[X]; const r = t[it]; if (r) for (const t of r) this[it].add(t); this[Z] = t[Z], this.addEventListener(ft, this.#s, { once: !0 }), this.addEventListener(gt, this.#a, { once: !0 }), this.addEventListener(ft, this.#c, { once: !0 }), this.addEventListener(gt, this.#u, { once: !0 }), this.addEventListener(yt, this.#h, { once: !0 }), this.addEventListener(wt, (() => { if (!this[et]) return this[lt](new n) })), this.addEventListener("*", this[Z].dispatchEvent.bind(this[Z])), this.addEventListener("*", t[K].dispatchEvent.bind(t[K])) } rollback = t => { if (this.#r) throw new r("Rollback invoked multiple times: Please raise an issue at https://github.com/virtualstate/navigation with the use case where you want to use a rollback multiple times, this may have been unexpected behaviour"); return this.#r = !0, this.#n.rollback(t) }; #c = () => { this[tt] = !0 }; #u = () => { this[et] = !0 }; #a = () => { this[z].resolve(this[Z]) }; #s = () => { this.signal.aborted || this[B].resolve(this[Z]) }; #h = t => this[lt](t.error);[ht] = (...t) => { for (const e of t) this.#i.delete(e) };[lt] = async t => { if (this[nt]) return; this[nt] = !0, this[wt](); const e = this[G]; if (("string" == typeof e || e === M) && (await this.dispatchEvent({ type: "navigateerror", error: t, get message() { return t instanceof Error ? t.message : `${t}` } }), e !== M && !((n = t) instanceof Error && "InvalidStateError" === n.name || i(t)))) try { await (this.rollback()?.finished) } catch (n) { throw new r("Failed to rollback, please raise an issue at https://github.com/virtualstate/navigation/issues") } var n; this[B].reject(t), this[z].reject(t) };[ot] = t => { const e = this, n = function () { if (!t) return; if (j(t)) return _("EVENT_INTERCEPT_HANDLER"), t; if ("function" == typeof t) return _("EVENT_INTERCEPT_HANDLER"), t(); const { handler: n, commit: i } = t; i && "string" == typeof i && e[bt].push(i); if ("function" != typeof n) return; return n() }(); if (this[st] = !0, !n) return; this[ct] = !0; const i = n.then((() => ({ status: "fulfilled", value: void 0 }))).catch((async t => (await this[lt](t), { status: "rejected", reason: t }))); this.#i.add(i) };[ut] = async () => { if (!this.#i.size) return this[Z]; try { const t = [...this.#i], e = (await Promise.all(t)).filter((t => "rejected" === t.status)); if (e.length) { if (1 === e.length) throw e[0].reason; if ("undefined" != typeof AggregateError) throw new AggregateError(e.map((({ reason: t }) => t))); throw new Error } return this[ht](...t), this[at] ? this[ut]() : this[Z] } catch (t) { throw await this.#h(t), await Promise.reject(t) } finally { await this[gt]() } };[wt]() { this.#o.signal.aborted || (this.#o.abort(), this.dispatchEvent({ type: wt, transition: this, entry: this[Z] })) } [gt] = async () => { this[et] || await this.dispatchEvent({ type: gt, transition: this, entry: this[Z], intercept: this[ot] }) } } function kt(t) { const e = function () { try { if ("undefined" != typeof window && window.location) return window.location.href } catch { } }() ?? "https://html.spec.whatwg.org/"; return new URL((t ?? "").toString(), e) } class xt { type; from; navigationType; constructor(t, e) { if (this.type = t, !e) throw new TypeError("init required"); if (!e.from) throw new TypeError("from required"); this.from = e.from, this.navigationType = e.navigationType ?? void 0 } } class Tt { type; canIntercept; canTransition; destination; downloadRequest; formData; hashChange; info; signal; userInitiated; navigationType; constructor(t, e) { if (this.type = t, !e) throw new TypeError("init required"); if (!e.destination) throw new TypeError("destination required"); if (!e.signal) throw new TypeError("signal required"); this.canIntercept = e.canIntercept ?? !1, this.canTransition = e.canIntercept ?? !1, this.destination = e.destination, this.downloadRequest = e.downloadRequest, this.formData = e.formData, this.hashChange = e.hashChange ?? !1, this.info = e.info, this.signal = e.signal, this.userInitiated = e.userInitiated ?? !1, this.navigationType = e.navigationType ?? "push" } commit() { throw new Error("Not implemented") } intercept(t) { throw new Error("Not implemented") } preventDefault() { throw new Error("Not implemented") } reportError(t) { throw new Error("Not implemented") } scroll() { throw new Error("Not implemented") } transitionWhile(t) { return this.intercept(t) } } const Lt = Symbol.for("@virtualstate/navigation/formData"), Pt = Symbol.for("@virtualstate/navigation/downloadRequest"), It = Symbol.for("@virtualstate/navigation/canIntercept"), Ut = Symbol.for("@virtualstate/navigation/userInitiated"), Rt = Symbol.for("@virtualstate/navigation/originalEvent"); function Ct() { } function Dt(t) { const { commit: e, currentIndex: n, options: i, known: o, currentEntry: s, transition: a, transition: { [J]: c, [Z]: u, [ot]: h }, reportError: l } = t; let { transition: { [G]: d } } = t, f = [...c]; const g = new Set(o); let v = -1, p = n; if (d === M) { const { index: t } = i ?? { index: void 0 }; if ("number" != typeof t) throw new r("Expected index to be provided for rollback"); v = t, p = t } else "traverse" === d || "reload" === d ? (v = function (t, e) { const n = e.index; return -1 !== n ? n : -1 }(0, u), p = v) : "replace" === d ? -1 === n ? (d = "push", v = n + 1, p = v) : (v = n, p = n) : (v = n + 1, p = v); if ("number" != typeof v || -1 === v) throw new r("Could not resolve next index"); if (!u.url) throw console.trace({ navigationType: d, entry: u, options: i }), new r("Expected entry url"); const y = { url: u.url, key: u.key, id: u.id, index: v, sameDocument: u.sameDocument, getState: () => u.getState() }; let m = !1; const w = kt(s?.url), b = new URL(y.url); if (w.hash !== b.hash) { const t = new URL(w.toString()); t.hash = ""; const e = new URL(b.toString()); e.hash = "", m = t.toString() === e.toString() } let E; const { resolve: S, promise: k } = function () { let t, e, n = !1, i = "pending"; const r = new Promise(((r, o) => { t = t => { i = "fulfilled", n = !0, r(t) }, e = t => { i = "rejected", n = !0, o(t) } })); return O(t), O(e), { get settled() { return n }, get status() { return i }, resolve: t, reject: e, promise: r } }(); function x() { O(E, "Expected contextToCommit"), S(e(E)) } const T = new D, L = new Tt("navigate", { signal: T.signal, info: void 0, ...i, canIntercept: i?.[It] ?? !0, formData: i?.[Lt] ?? void 0, downloadRequest: i?.[Pt] ?? void 0, hashChange: m, navigationType: i?.navigationType ?? ("string" == typeof d ? d : "replace"), userInitiated: i?.[Ut] ?? !1, destination: y }), P = i?.[Rt], I = a[wt].bind(a); if (P) { const t = P; L.intercept = function (e) { return t.preventDefault(), h(e) }, L.preventDefault = function () { return t.preventDefault(), I() } } else L.intercept = h, L.preventDefault = I; L.transitionWhile = L.intercept, L.commit = x, l && (L.reportError = l), L.scroll = Ct, P && (L.originalEvent = P); const U = new xt("currententrychange", { from: s, navigationType: L.navigationType }); let R = [], C = [], j = []; const N = c.map((t => t.key)); if (d === M) { const { entries: t } = i ?? { entries: void 0 }; if (!t) throw new r("Expected entries to be provided for rollback"); f = t, f.forEach((t => g.add(t))); const e = f.map((t => t.key)); C = c.filter((t => !e.includes(t.key))), j = f.filter((t => !N.includes(t.key))) } else if ("replace" === d || "traverse" === d || "reload" === d) { f[y.index] = u, "traverse" !== d && R.push(u), "replace" === d && (f = f.slice(0, y.index + 1)); const t = f.map((t => t.key)); C = c.filter((e => !t.includes(e.key))), N.includes(u.id) && (j = [u]) } else if ("push" === d) { let t = !1; if (f[y.index] && (f = f.slice(0, y.index), t = !0), f.push(u), j = [u], t) { const t = f.map((t => t.key)); C = c.filter((e => !t.includes(e.key))) } } let A; return g.add(u), (R.length || j.length || C.length) && (A = { updatedEntries: R, addedEntries: j, removedEntries: C }), E = { entries: f, index: p, known: g, entriesChange: A }, { entries: f, known: g, index: p, currentEntryChange: U, destination: y, navigate: L, navigationType: d, waitForCommit: k, commit: x, abortController: T } } function jt(t) { if ("undefined" != typeof CustomEvent && "string" == typeof t.type) { if (t instanceof CustomEvent) return t; const { type: n, detail: i, ...r } = t, o = new CustomEvent(n, { detail: i ?? r }); return Object.assign(o, r), function (t, n) { if (!e(t)) throw new Error("Expected event"); if (void 0 !== n && t.type !== n) throw new Error(`Expected event type ${String(n)}, got ${t.type.toString()}`) }(o, t.type), o } return t } const Ot = Symbol.for("@virtualstate/navigation/setOptions"), Nt = Symbol.for("@virtualstate/navigation/setEntries"), At = Symbol.for("@virtualstate/navigation/setCurrentIndex"), Ft = Symbol.for("@virtualstate/navigation/setCurrentKey"), qt = Symbol.for("@virtualstate/navigation/getState"), $t = Symbol.for("@virtualstate/navigation/setState"), Ht = Symbol.for("@virtualstate/navigation/disposeState"); class Vt extends b { #l = 0; #d = []; #f = new Set; #g = -1; #v; #p = new WeakSet; #y = ""; #m = void 0; #n = void 0; get canGoBack() { return !!this.#d[this.#g - 1] } get canGoForward() { return !!this.#d[this.#g + 1] } get currentEntry() { return -1 === this.#g ? (this.#m || (this.#m = new I({ getState: this[qt], navigationType: "push", index: -1, sameDocument: !1, url: this.#y.toString() })), this.#m) : this.#d[this.#g] } get transition() { const t = this.#v; return t?.signal.aborted ? void 0 : t } constructor(t = {}) { super(), this[Ot](t) } [Ot](t) { this.#n = t, this.#y = kt(t?.baseURL), this.#d = [], t.entries && this[Nt](t.entries), t.currentKey ? this[Ft](t.currentKey) : "number" == typeof t.currentIndex && this[At](t.currentIndex) } [Ft](t) { const e = this.#d.findIndex((e => e.key === t)); -1 !== e && (this.#g = e) } [At](t) { t <= -1 || t >= this.#d.length || (this.#g = t) } [Nt](t) { this.#d = t.map((({ key: t, url: e, navigationType: n, state: i, sameDocument: r }, o) => { return new I({ getState: this[qt], navigationType: (s = n, "reload" === s || "push" === s || "replace" === s || "traverse" === s ? n : "push"), sameDocument: r ?? !0, index: o, url: e, key: t, state: i }); var s })), -1 === this.#g && this.#d.length && (this.#g = 0) } [qt] = t => this.#n?.getState?.(t) ?? void 0;[$t] = t => this.#n?.setState?.(t);[Ht] = t => this.#n?.disposeState?.(t); back(t) { if (!this.canGoBack) throw new r("Cannot go back"); const e = this.#d[this.#g - 1]; return this.#w("traverse", this.#b(e, { ...t, navigationType: "traverse" })) } entries() { return [...this.#d] } forward(t) { if (!this.canGoForward) throw new r; const e = this.#d[this.#g + 1]; return this.#w("traverse", this.#b(e, { ...t, navigationType: "traverse" })) } goTo(t, e) { return this.traverseTo(t, e) } traverseTo(t, e) { const n = this.#d.find((e => e.key === t)); if (n) return this.#w("traverse", this.#b(n, { ...e, navigationType: "traverse" })); throw new r } #E = t => { const e = this.currentEntry?.url; return !e || (n = new URL(e), i = new URL(t), n.origin === i.origin); var n, i }; navigate(t, e) { let n = this.#y; this.currentEntry?.url && (n = this.currentEntry?.url); const i = new URL(t, n).toString(); let r = "push"; "auto" !== e?.history && e?.history ? "push" !== e?.history && "replace" !== e?.history || (r = e?.history) : i === this.currentEntry?.url && (r = "replace"); const o = this.#S({ getState: this[qt], url: i, ...e, sameDocument: this.#E(i), navigationType: r }); return this.#w(r, o, void 0, e) } #b = (t, e) => this.#S({ ...t, getState: this[qt], index: t?.index ?? void 0, state: e?.state ?? t?.getState(), navigationType: t?.[k] ?? ("string" == typeof e?.navigationType ? e.navigationType : "replace"), ...e, get [x]() { return t?.[x] }, get [a]() { return t?.[a] } }); #S = t => { const e = t.key || ("replace" === t.navigationType ? this.currentEntry?.key : void 0), n = new I({ ...t, key: e, index: t.index ?? (() => this.#d.indexOf(n)) }); return n }; #w = (t, e, n, i) => { if (e === this.currentEntry) throw new r; if (this.#d.findIndex((t => t.id === e.id)) > -1) throw new r; return this.#k(t, e, n, i) }; #k = (t, e, n, i) => { const r = n ?? new St({ from: this.currentEntry, navigationType: "string" == typeof t ? t : "replace", rollback: t => this.#x(r, t), [G]: t, [J]: [...this.#d], [Q]: this.#g, [it]: [...this.#f], [Z]: e, [K]: this }), { finished: o, committed: s } = r; return this.#T(r), (() => this.#L(t, e, r, i))().catch((t => { })), { committed: s, finished: o } }; #T = t => { this.#p.add(t) }; #L = (t, e, n, i) => { try { return this.#l += 1, this.#P(t, e, n, i) } finally { this.#l -= 1 } }; #x = (t, e) => { const n = t[J], i = t[Q], r = n[i], o = r ? this.#b(r, e) : void 0, s = { ...e, index: i, known: new Set([...this.#f, ...n]), navigationType: o?.[k] ?? "replace", entries: n }, a = o ? M : W, c = o ?? this.#S({ getState: this[qt], navigationType: "replace", index: s.index, sameDocument: !0, ...e }); return this.#w(a, c, void 0, s) }; #P = (t, e, n, i) => { let o = t; const s = _t(); s && e.sameDocument && "string" == typeof o && s?.mark?.(`same-document-navigation:${e.id}`); let a = !1, c = !1; const { currentEntry: u } = this; this.#v?.finished?.catch((t => t)), this.#v?.[z]?.promise?.catch((t => t)), this.#v?.[B]?.promise?.catch((t => t)), this.#v?.[wt](), this.#v = n; const h = n.dispatchEvent({ type: vt, transition: n, entry: e }), l = ({ entries: t, index: e, known: i }) => { n.signal.aborted || (this.#d = t, i && (this.#f = new Set([...this.#f, ...i])), this.#g = e, this[$t](this.currentEntry)) }, d = async t => { if (c) return; const i = [n.dispatchEvent(jt({ type: dt, transition: n, entry: e }))]; if (n.signal.aborted) return; c = !0, l(t); const { entriesChange: r } = t; i.push(n.dispatchEvent(jt({ type: ft, transition: n, entry: e }))), r && i.push(this.dispatchEvent(jt({ type: "entrieschange", ...r }))), await Promise.all(i) }, f = async () => { if (await h, "number" != typeof i?.index || !i.entries) throw new r; const t = this.entries(), n = t.map((t => t.key)), o = i.entries.map((t => t.key)), s = t.filter((t => !o.includes(t.key))), c = i.entries.filter((t => !n.includes(t.key))); return await d({ entries: i.entries, index: i.index, known: i.known, entriesChange: s.length || c.length ? { removedEntries: s, addedEntries: c, updatedEntries: [] } : void 0 }), await this.dispatchEvent(jt({ type: "currententrychange" })), a = !0, e }, g = () => { if (t === W) return f(); const r = Dt({ currentEntry: u, currentIndex: this.#g, options: i, transition: n, known: this.#f, commit: d, reportError: n[lt] }), s = new Promise(queueMicrotask); let c = []; const h = function* (t) { const i = new Promise(queueMicrotask), { currentEntryChange: r, navigate: s, waitForCommit: c, commit: h, abortController: l } = t, d = l.abort.bind(l); if (n.signal.addEventListener("abort", d, { once: !0 }), "string" == typeof o || o === M) { const t = u?.dispatchEvent(jt({ type: "navigatefrom", intercept: n[ot], transitionWhile: n[ot] })); t && (yield t) } "string" == typeof o && (yield n.dispatchEvent(s)); n[Et] || h(); yield c, e.sameDocument && (yield n.dispatchEvent(r)); a = !0, "string" == typeof o && (yield e.dispatchEvent(jt({ type: "navigateto", intercept: n[ot], transitionWhile: n[ot] }))); yield v(), n[rt].size || (yield i); yield n.dispatchEvent({ type: pt, transition: n, entry: e }), yield n[ut](), n.signal.removeEventListener("abort", d), yield n[gt](), "string" == typeof o && (yield n.dispatchEvent(jt({ type: "finish", intercept: n[ot], transitionWhile: n[ot] })), yield n.dispatchEvent(jt({ type: "navigatesuccess", intercept: n[ot], transitionWhile: n[ot] }))) }(r)[Symbol.iterator](), l = { [Symbol.iterator]: () => ({ next: () => h.next() }) }; async function g() { const t = [...c]; if (t.length) { c = []; const e = (await Promise.all(t)).filter(N); if (1 === e.length) throw await Promise.reject(e[0]); if (e.length) throw new AggregateError(e, e[0].reason?.message) } else n[st] || await s } return async function t() { for (const e of l) { if (j(e) && c.push(Promise.allSettled([e]).then((([t]) => t))), n[Et] || a && n[ct]) return g().then(t); if (n.signal.aborted) break } if (c.length) return g() }().then((() => n[st] ? void 0 : s)).then((() => e)) }, v = async () => this.#I(); return Promise.allSettled([(() => { try { return g() } catch (t) { return Promise.reject(t) } })()]).then((async ([t]) => { "rejected" === t.status && await n.dispatchEvent({ type: yt, error: t.reason, transition: n, entry: e }), await v(), await n.dispatchEvent({ type: mt, transition: n, entry: e }), await n[ut](), this.#v === n && (this.#v = void 0), e.sameDocument && "string" == typeof o && (s.mark(`same-document-navigation-finish:${e.id}`), s.measure(`same-document-navigation:${e.url}`, `same-document-navigation:${e.id}`, `same-document-navigation-finish:${e.id}`)) })).then((() => e)) }; #I = async () => { for (const t of this.#f) { if (-1 !== this.#d.findIndex((e => e.id === t.id))) continue; this.#f.delete(t); const e = jt({ type: "dispose", entry: t }); this[Ht](t), await t.dispatchEvent(e), await this.dispatchEvent(e) } }; reload(t) { const { currentEntry: e } = this; if (!e) throw new r; const n = this.#b(e, t); return this.#w("reload", n, void 0, t) } updateCurrentEntry(t) { const { currentEntry: e } = this; if (!e) throw new r("Expected current entry"); e[T](t.state), this[$t](e); const n = new xt("currententrychange", { from: e, navigationType: void 0 }), i = jt({ type: "entrieschange", addedEntries: [], removedEntries: [], updatedEntries: [e] }); return Promise.all([this.dispatchEvent(n), this.dispatchEvent(i)]) } } function _t() { return "undefined" != typeof performance ? performance : { now: () => Date.now(), mark() { }, measure() { } } } let Mt; function Wt() { return t || (Mt || (Mt = new Vt)) } let Kt = JSON; function zt(t) { Kt = t } const Bt = Symbol.for("@virtualstate/navigation/location/checkChange"), Gt = Symbol.for("@virtualstate/navigation/location/awaitFinished"), Jt = Symbol.for("@virtualstate/navigation/location/transitionURL"), Yt = Symbol.for("@virtualstate/navigation/location/url"); class Qt { #n; #U; constructor(t) { this.#n = t, this.#U = t.navigation; const e = () => { this.#R = void 0, this.#y = void 0 }; this.#U.addEventListener("navigate", (() => { const t = this.#U.transition; t && function (t) { return B in t }(t) && t[B].promise.then(e, e) })), this.#U.addEventListener("currententrychange", e) } #C = new WeakMap; #R; #y; get [Yt]() { if (this.#R) return this.#R; const { currentEntry: t } = this.#U; if (!t) return this.#y = kt(this.#n.baseURL), this.#y; const e = this.#C.get(t); if (e) return e; const n = new URL(t.url ?? "https://html.spec.whatwg.org/"); return this.#C.set(t, n), n } get hash() { return this[Yt].hash } set hash(t) { this.#D("hash", t) } get host() { return this[Yt].host } set host(t) { this.#D("host", t) } get hostname() { return this[Yt].hostname } set hostname(t) { this.#D("hostname", t) } get href() { return this[Yt].href } set href(t) { this.#D("href", t) } get origin() { return this[Yt].origin } get pathname() { return this[Yt].pathname } set pathname(t) { this.#D("pathname", t) } get port() { return this[Yt].port } set port(t) { this.#D("port", t) } get protocol() { return this[Yt].protocol } set protocol(t) { this.#D("protocol", t) } get search() { return this[Yt].search } set search(t) { this.#D("search", t) } #D = (t, e) => { const n = this[Yt].toString(); let i; "href" === t ? i = new URL(e, n) : (i = new URL(n), i[t] = e); const r = i.toString(); n !== r && this.#j(i, (() => this.#U.navigate(r))) }; replace(t) { return this.#j(t, (t => this.#U.navigate(t.toString(), { history: "replace" }))) } reload() { return this.#O(this.#U.reload()) } assign(t) { return this.#j(t, (t => this.#U.navigate(t.toString()))) } [Jt](t, e) { return this.#j(t, e) } #j = async (t, e) => { const n = this.#R = "string" == typeof t ? new URL(t, this[Yt].toString()) : t; try { await this.#O(e(n)) } finally { this.#R === n && (this.#R = void 0) } };[Gt](t) { return this.#O(t) } #O = async t => { if (this.#y = void 0, !t) return; const { committed: e, finished: n } = t; await Promise.all([e || Promise.resolve(void 0), n || Promise.resolve(void 0)]) }; #N = () => { const t = this[Yt], e = t.toString(), n = this.#U.currentEntry?.url; if (e !== n) return this.#j(t, (() => this.#U.navigate(e))) };[Bt]() { return this.#N() } } const Xt = Symbol.for("@virtualstate/navigation/history/state"); class Zt extends Qt { #n; #U; constructor(t) { super(t), this.#n = t, this.#U = t.navigation } get length() { return this.#U.entries().length } scrollRestoration = "manual"; get state() { const t = this.#U.currentEntry?.getState(); return "string" == typeof t || "number" == typeof t || "boolean" == typeof t ? t : this.#n[Xt] ?? void 0 } back() { const t = this.#U.entries()[(this.#U.currentEntry?.index ?? -1) - 1], e = t?.url; if (!e) throw new r("Cannot go back"); return this[Jt](e, (() => this.#U.back())) } forward() { const t = this.#U.entries()[(this.#U.currentEntry?.index ?? -1) + 1], e = t?.url; if (!e) throw new r("Cannot go forward"); return this[Jt](e, (() => this.#U.forward())) } go(t) { if ("number" != typeof t || 0 === t || isNaN(t)) return this[Gt](this.#U.reload()); const e = this.#U.entries(), { currentEntry: n } = this.#U; if (!n) throw new Error(`Could not go ${t}`); const i = e[n.index + t]; if (!i) throw new Error(`Could not go ${t}`); const r = i.key; return this[Gt](this.#U.traverseTo(r)) } replaceState(t, e, n) { return n ? this[Jt](n, (e => this.#U.navigate(e.toString(), { state: t, history: "replace" }))) : this.#U.updateCurrentEntry({ state: t }) } pushState(t, e, n) { return n ? this[Jt](n, (e => this.#U.navigate(e.toString(), { state: t }))) : this.#U.updateCurrentEntry({ state: t }) } } const te = "undefined" == typeof window ? void 0 : window, ee = "undefined" == typeof self ? void 0 : self, ne = "__@virtualstate/navigation/key", ie = "__@virtualstate/navigation/meta"; function re(t) { return A(t) && !0 === t[ie] } function oe(t) { return A(t) && re(t[ne]) } function se(t, e = le.limit) { let n = t.entries(); return "number" == typeof e && (n = n.slice(-e)), n.map((({ id: t, key: e, url: n, sameDocument: i }) => ({ id: t, key: e, url: n, sameDocument: i }))) } function ae(t, e, n = le.limit) { return { [ie]: !0, currentIndex: e.index, key: e.key, entries: se(t, n), state: e.getState() } } function ce(t, e, n = le.limit) { return { [ne]: ae(t, e, n) } } function ue(t, e, n, i, r) { !function () { if ("undefined" == typeof sessionStorage) return; try { const i = (e = ce(t, n, r), Kt.stringify(e)); sessionStorage.setItem(n.key, i) } catch { } var e }() } function he(t, e) { return function () { const n = function () { const e = t.originalState ?? function () { try { return t.state } catch { return } }(); return A(e) ? e : void 0 }(); return oe(n) ? n[ne].key !== e.key ? void 0 : n[ne].state : void 0 }() ?? function () { if ("undefined" == typeof sessionStorage) return; try { const n = sessionStorage.getItem(e.key); if (!n) return; const i = (t = n, Kt.parse(t)); if (!A(i)) return; if (!oe(i)) return; return i[ne].state } catch { return } var t }() } const le = Object.freeze({ persist: !0, persistState: !0, history: !0, limit: 50, patch: !0, interceptEvents: !0 }); function de(t) { return A(t) && "function" == typeof t[Nt] && "function" == typeof t[Ft] } function fe(t, e) { e.addEventListener("click", (n => { if (n.target?.ownerDocument === e.document) { const i = ge(n); A(i) && function (n, i) { !function () { if (0 !== (r = n).button || r.defaultPrevented || r.metaKey || r.altKey || r.ctrlKey || r.shiftKey) return; var r; O(n); const o = i.getAttribute("target"); if (o) { if ("_blank" === o) return; if (o !== e.name) return } const s = { history: "auto", [Ut]: !0, [Pt]: i.download, [Rt]: n }; t.navigate(i.href, s) }() }(n, i) } })), e.addEventListener("submit", (n => { if (n.target?.ownerDocument === e.document) { const i = ve(n); A(i) && function (n, i) { !function () { if (n.defaultPrevented) return; const r = n.submitter && "formMethod" in n.submitter && n.submitter.formMethod ? n.submitter.formMethod : i.method; if ("dialog" === r) return; const o = n.submitter && "formAction" in n.submitter && n.submitter.formAction ? n.submitter.formAction : i.action, s = i.getAttribute("target"); if (s) { if ("_blank" === s) return; if (s !== e.name) return } let a; try { a = new FormData(i) } catch { a = new FormData(void 0) } const c = "get" === r ? new URLSearchParams([...a].map((([t, e]) => e instanceof File ? [t, e.name] : [t, e]))) : void 0, u = "post" === r ? a : void 0, h = new URL(o, t.currentEntry.url); c && (h.search = c.toString()); const l = n; O(l); const d = { history: "auto", [Ut]: !0, [Lt]: u, [Rt]: l }; t.navigate(h.href, d) }() }(n, i) } })) } function ge(t) { return we(pe(t), "a[href]:not([data-navigation-ignore])") } function ve(t) { return we(pe(t), "form:not([data-navigation-ignore])") } function pe(t) { if (!t.composedPath) return t.target; return t.composedPath()[0] ?? t.target } function ye(t, e, n) { !function () { if (function (t) { try { Object.defineProperty(t, "navigation", { value: n }) } catch (t) { } if (!t.history) try { Object.defineProperty(t, "history", { value: e }) } catch (t) { } }(t), t !== te) return; if (ee) try { Object.defineProperty(ee, "navigation", { value: n }) } catch (t) { } if ("undefined" != typeof globalThis) try { Object.defineProperty(globalThis, "navigation", { value: n }) } catch (t) { } }(), function () { if (!t.PopStateEvent) return; const e = t.PopStateEvent.prototype; if (!e) return; const n = Object.getOwnPropertyDescriptor(e, "state"); Object.defineProperty(e, "state", { ...n, get() { const t = n.get.call(this); return oe(t) ? t[ne].state : t } }), Object.defineProperty(e, "originalState", { ...n }) }(), function () { if (e instanceof Zt) return; const t = new Zt({ navigation: n }), i = t.pushState.bind(t), r = t.replaceState.bind(t), o = t.go.bind(t), s = t.back.bind(t), a = t.forward.bind(t), c = Object.getPrototypeOf(e), u = { pushState: { ...Object.getOwnPropertyDescriptor(c, "pushState"), value: i }, replaceState: { ...Object.getOwnPropertyDescriptor(c, "replaceState"), value: r }, go: { ...Object.getOwnPropertyDescriptor(c, "go"), value: o }, back: { ...Object.getOwnPropertyDescriptor(c, "back"), value: s }, forward: { ...Object.getOwnPropertyDescriptor(c, "forward"), value: a } }; Object.defineProperties(c, u); const h = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), "state"); Object.defineProperty(e, "state", { ...h, get: () => t.state }), Object.defineProperty(e, "originalState", { ...h }) }() } function me(t = le) { const { persist: e, persistState: n, history: i, limit: o, patch: s, interceptEvents: a, window: c = te, navigation: u } = { ...le, ...t }, h = e || n, l = c ?? te, d = t.history && "boolean" != typeof t.history ? t.history : function (t = te) { if (void 0 !== t) return t.history }(l); if (!d) return function (t) { const e = [{ key: E() }], n = t ?? new Vt({ entries: e }), i = new Zt({ navigation: n }); return { navigation: n, history: i, apply() { de(t) && !n.entries().length && t[Nt](e) } } }(); O(l, "window required when using polyfill with history, this shouldn't be seen"); const f = l.location, g = d?.state; let v = { [ie]: !0, currentIndex: -1, entries: [], key: "", state: void 0 }; oe(g) && (v = g[ne]); let p = v.entries; const y = !(!c && !i || !d); if (!p.length) { let t, e; f?.href && (t = f.href), oe(g) || re(g) || (e = g); const n = E(); p = [{ key: n, state: e, url: t }], v.key = n, v.currentIndex = 0 } const m = { entries: p, currentIndex: v?.currentIndex, currentKey: v?.key, getState(t) { if (y) return he(d, t) }, setState(t) { y && t.sameDocument && ue(w, 0, t, 0, o) }, disposeState(t) { y && function (t, e) { e && "undefined" != typeof sessionStorage && sessionStorage.removeItem(t.key) }(t, h) } }, w = u ?? new Vt(m), b = d?.pushState.bind(d), S = d?.replaceState.bind(d), k = d?.go.bind(d); return { navigation: w, history: d, apply() { if (de(w) && w[Ot](m), y) { const t = new Set, i = new Set; w.addEventListener("navigate", (t => { if (t.destination.sameDocument) { if (w.transition instanceof St) { const { transition: e } = w, { destination: n } = t; e.addEventListener(dt, (() => { e[st] || ("push" === e.navigationType ? f.href = n.url : "reload" === e.navigationType && f.reload(), e[wt]()) }), { once: !0 }) } } else t.intercept({ commit: "after-transition", async handler() { queueMicrotask((() => { t.signal.aborted || function () { if (A(t.originalEvent)) { const e = ge(t.originalEvent); if (e) return function (t) { const e = t.cloneNode(); e.setAttribute("data-navigation-ignore", "1"), e.click() }(e); { const e = ve(t.originalEvent); if (e) return function (t) { const e = t.cloneNode(); e.setAttribute("data-navigation-ignore", "1"), e.submit() }(e) } } f.href = t.destination.url }() })) } }) })), w.addEventListener("currententrychange", (({ navigationType: e, from: n }) => { const { currentEntry: r, transition: s } = w; if (!r) return; const { key: a, url: c } = r; if (i.delete(a) || !r?.sameDocument) return; const u = ce(w, r, o); switch (e || "replace") { case "push": return b(u, "", c); case "replace": return S(u, "", c); case "traverse": const e = r.index - n.index; return t.add(a), k(e) } })), l.addEventListener("popstate", (s => { const { state: a, originalState: c } = s, u = c ?? a; if (!oe(u)) return; const { [ne]: { key: h } } = u; if (t.delete(h)) return; let l; i.add(h); try { l = w.traverseTo(h).committed } catch (t) { if (t instanceof r && !e) return; throw t } (e || n) && l.then((t => { const e = ce(w, t, o); S(e, "", t.url) })).catch((() => { })) })) } if (a && fe(w, l), s && ye(l, d, w), !d.state) { const t = ce(w, w.currentEntry, o); S(t, "", w.currentEntry.url) } } } } function we(t, e) { let n = t ? t.matches instanceof Function ? t : t.parentElement : void 0; for (; n;) { if (n.matches(e)) return O(n), n; n = n.parentElement ?? n.getRootNode()?.host } return } const be = Wt(); if (function (e = Wt()) { const n = globalThis; return e !== t && !Object.hasOwn(n, "navigation") && "undefined" != typeof window }(be)) try { !function (t = le) { const { apply: e, navigation: n } = me(t); e() }({ navigation: be }) } catch (t) { console.error("Failed to apply polyfill"), console.error(t) } export { H as setIgnoreWarnings, zt as setSerializer, V as setTraceWarnings }; export default null;
//# sourceMappingURL=/sm/ff5edad5f56d3aee1ba11d5053bbaf100188cb85c52bc1f72b13cbabd73cd103.map
//polyfill from https://cdn.jsdelivr.net/npm/@virtualstate/navigation/polyfill/+esm 
// 26.feb.26

import { WeakDictionaryOfSets } from "./1_PortalMap.js";


const TRIGGERS = new WeakDictionaryOfSets();

function portalDispatch(e) {
  const res = TRIGGERS.get(e.type);
  res && eventLoopCube.dispatchBatch(e, res);
}

function Portal(name, root, eventname, reaction) {
  reaction ??= NAME => () => portalDispatch(new Event(eventname));
  return {
    onFirstConnect: function () {
      TRIGGERS.put(name, this, _ => root.removeEventListener(eventname, portalDispatch));
      root.addEventListener(eventname, portalDispatch);
    },
    reaction,
  };
}

const Portals = Object.create(null);
Portals["viewport-resize"] = Portal("viewport-resize", window.visualViewport, "resize");
Portals["viewport-scroll"] = Portal("viewport-scroll", window.visualViewport, "scroll");
Portals.orientation = Portal("orientation", screen.orientation, "change", href => globalThis.navigation.navigate(href));
Portals.navigate = Portal("navigate", globalThis.navigation, "navigate");

export { Portals };